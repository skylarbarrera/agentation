{"version":3,"sources":["../src/index.ts","../src/types.ts","../src/server/sqlite.ts","../src/server/http.ts","../src/utils.ts","../src/server/mcp.ts"],"sourcesContent":["/**\n * Agentation RN MCP Server\n * MCP server for Agentation React Native\n *\n * @see https://github.com/benjitaylor/agentation/blob/main/mcp/src/index.ts\n */\n\n// Types\nexport type {\n  Annotation,\n  AnnotationIntent,\n  AnnotationSeverity,\n  AnnotationStatus,\n  ThreadMessage,\n  Session,\n  SessionStatus,\n  SessionWithAnnotations,\n  ActionRequest,\n  ActionResponse,\n  HealthCheckResponse,\n  ServerConfig,\n} from './types';\n\nexport { DEFAULT_CONFIG } from './types';\n\n// Server components\nexport { createDatabase } from './server/sqlite';\nexport { createHttpServer, startHttpServer } from './server/http';\nexport { createMcpServer, startMcpServer } from './server/mcp';\n\n// Utilities\nexport { generateId, parseWebhookUrls } from './utils';\n","/**\n * MCP Server Types\n * Shared types between MCP server and clients\n *\n * @see https://github.com/benjitaylor/agentation/blob/main/mcp/src/types.ts\n */\n\n// =============================================================================\n// Annotation Types\n// =============================================================================\n\nexport type AnnotationIntent = 'fix' | 'change' | 'question' | 'approve';\nexport type AnnotationSeverity = 'blocking' | 'important' | 'suggestion';\nexport type AnnotationStatus = 'pending' | 'acknowledged' | 'resolved' | 'dismissed';\n\nexport type ThreadMessage = {\n  id: string;\n  role: 'human' | 'agent';\n  content: string;\n  timestamp: number;\n};\n\nexport type Annotation = {\n  id: string;\n  x: number;\n  y: number;\n  comment: string;\n  element: string;\n  elementPath: string;\n  timestamp: number;\n  selectedText?: string;\n  boundingBox?: { x: number; y: number; width: number; height: number };\n  nearbyText?: string;\n  cssClasses?: string;\n  nearbyElements?: string;\n  computedStyles?: string;\n  fullPath?: string;\n  accessibility?: string;\n  isMultiSelect?: boolean;\n  isFixed?: boolean;\n  reactComponents?: string;\n  elementBoundingBoxes?: Array<{ x: number; y: number; width: number; height: number }>;\n\n  // Protocol fields\n  sessionId?: string;\n  url?: string;\n  intent?: AnnotationIntent;\n  severity?: AnnotationSeverity;\n  status?: AnnotationStatus;\n  thread?: ThreadMessage[];\n  createdAt?: string;\n  updatedAt?: string;\n  resolvedAt?: string;\n  resolvedBy?: 'human' | 'agent';\n  authorId?: string;\n\n  // RN-specific fields\n  routeName?: string;\n  componentType?: string;\n  sourcePath?: string;\n  lineNumber?: number;\n  columnNumber?: number;\n  testID?: string;\n  platform?: 'ios' | 'android';\n\n  // Sync tracking\n  _syncedTo?: string;\n};\n\n// =============================================================================\n// Session Types\n// =============================================================================\n\nexport type SessionStatus = 'active' | 'approved' | 'closed';\n\nexport type Session = {\n  id: string;\n  url: string;\n  status: SessionStatus;\n  createdAt: string;\n  updatedAt?: string;\n  projectId?: string;\n  metadata?: Record<string, unknown>;\n};\n\nexport type SessionWithAnnotations = Session & {\n  annotations: Annotation[];\n};\n\n// =============================================================================\n// API Types\n// =============================================================================\n\nexport type ActionRequest = {\n  sessionId: string;\n  annotations: Annotation[];\n  output: string;\n  timestamp: string;\n};\n\nexport type ActionResponse = {\n  success: boolean;\n  message?: string;\n  actionId?: string;\n};\n\nexport type HealthCheckResponse = {\n  status: 'ok';\n  version: string;\n};\n\n// =============================================================================\n// MCP Tool Input Types\n// =============================================================================\n\nexport type ListSessionsInput = {\n  status?: SessionStatus;\n  limit?: number;\n};\n\nexport type GetSessionInput = {\n  sessionId: string;\n};\n\nexport type GetPendingInput = {\n  sessionId: string;\n};\n\nexport type AcknowledgeInput = {\n  annotationId: string;\n};\n\nexport type ResolveInput = {\n  annotationId: string;\n  message?: string;\n};\n\nexport type DismissInput = {\n  annotationId: string;\n  reason: string;\n};\n\nexport type ReplyInput = {\n  annotationId: string;\n  message: string;\n};\n\nexport type WaitForActionInput = {\n  sessionId: string;\n  timeoutMs?: number;\n};\n\n// =============================================================================\n// Server Configuration\n// =============================================================================\n\nexport type ServerConfig = {\n  port: number;\n  dbPath: string;\n  webhookUrls?: string[];\n};\n\nexport const DEFAULT_CONFIG: ServerConfig = {\n  port: 4848,\n  dbPath: '~/.agentation-rn/store.db',\n};\n","/**\n * SQLite Storage for MCP Server\n * Persists sessions and annotations to disk\n *\n * @see https://github.com/benjitaylor/agentation/blob/main/mcp/src/server/sqlite.ts\n */\n\nimport Database from 'better-sqlite3';\nimport { existsSync, mkdirSync } from 'fs';\nimport { dirname, resolve } from 'path';\nimport { homedir } from 'os';\nimport type { Annotation, Session, SessionWithAnnotations, SessionStatus } from '../types';\n\n// =============================================================================\n// Database Setup\n// =============================================================================\n\nfunction expandPath(path: string): string {\n  if (path.startsWith('~')) {\n    return path.replace('~', homedir());\n  }\n  return resolve(path);\n}\n\nfunction ensureDir(filePath: string): void {\n  const dir = dirname(filePath);\n  if (!existsSync(dir)) {\n    mkdirSync(dir, { recursive: true });\n  }\n}\n\nexport function createDatabase(dbPath: string): Database.Database {\n  const expandedPath = expandPath(dbPath);\n  ensureDir(expandedPath);\n\n  const db = new Database(expandedPath);\n\n  // Enable WAL mode for better concurrent access\n  db.pragma('journal_mode = WAL');\n\n  // Create tables\n  db.exec(`\n    CREATE TABLE IF NOT EXISTS sessions (\n      id TEXT PRIMARY KEY,\n      url TEXT NOT NULL,\n      status TEXT NOT NULL DEFAULT 'active',\n      created_at TEXT NOT NULL,\n      updated_at TEXT,\n      project_id TEXT,\n      metadata TEXT\n    );\n\n    CREATE TABLE IF NOT EXISTS annotations (\n      id TEXT PRIMARY KEY,\n      session_id TEXT NOT NULL,\n      data TEXT NOT NULL,\n      created_at TEXT NOT NULL,\n      updated_at TEXT,\n      FOREIGN KEY (session_id) REFERENCES sessions(id) ON DELETE CASCADE\n    );\n\n    CREATE INDEX IF NOT EXISTS idx_annotations_session ON annotations(session_id);\n    CREATE INDEX IF NOT EXISTS idx_sessions_status ON sessions(status);\n    CREATE INDEX IF NOT EXISTS idx_sessions_url ON sessions(url);\n  `);\n\n  return db;\n}\n\n// =============================================================================\n// Session Operations\n// =============================================================================\n\nexport function createSession(\n  db: Database.Database,\n  id: string,\n  url: string,\n  projectId?: string,\n  metadata?: Record<string, unknown>\n): Session {\n  const now = new Date().toISOString();\n\n  const stmt = db.prepare(`\n    INSERT INTO sessions (id, url, status, created_at, project_id, metadata)\n    VALUES (?, ?, 'active', ?, ?, ?)\n  `);\n\n  stmt.run(id, url, now, projectId ?? null, metadata ? JSON.stringify(metadata) : null);\n\n  return {\n    id,\n    url,\n    status: 'active',\n    createdAt: now,\n    projectId,\n    metadata,\n  };\n}\n\nexport function getSession(\n  db: Database.Database,\n  sessionId: string\n): Session | null {\n  const stmt = db.prepare(`\n    SELECT id, url, status, created_at, updated_at, project_id, metadata\n    FROM sessions\n    WHERE id = ?\n  `);\n\n  const row = stmt.get(sessionId) as {\n    id: string;\n    url: string;\n    status: SessionStatus;\n    created_at: string;\n    updated_at: string | null;\n    project_id: string | null;\n    metadata: string | null;\n  } | undefined;\n\n  if (!row) return null;\n\n  return {\n    id: row.id,\n    url: row.url,\n    status: row.status,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at ?? undefined,\n    projectId: row.project_id ?? undefined,\n    metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\n  };\n}\n\nexport function getSessionWithAnnotations(\n  db: Database.Database,\n  sessionId: string\n): SessionWithAnnotations | null {\n  const session = getSession(db, sessionId);\n  if (!session) return null;\n\n  const annotations = getAnnotationsForSession(db, sessionId);\n\n  return {\n    ...session,\n    annotations,\n  };\n}\n\nexport function listSessions(\n  db: Database.Database,\n  status?: SessionStatus,\n  limit: number = 100\n): Session[] {\n  let query = `\n    SELECT id, url, status, created_at, updated_at, project_id, metadata\n    FROM sessions\n  `;\n\n  const params: unknown[] = [];\n\n  if (status) {\n    query += ' WHERE status = ?';\n    params.push(status);\n  }\n\n  query += ' ORDER BY created_at DESC LIMIT ?';\n  params.push(limit);\n\n  const stmt = db.prepare(query);\n  const rows = stmt.all(...params) as Array<{\n    id: string;\n    url: string;\n    status: SessionStatus;\n    created_at: string;\n    updated_at: string | null;\n    project_id: string | null;\n    metadata: string | null;\n  }>;\n\n  return rows.map((row) => ({\n    id: row.id,\n    url: row.url,\n    status: row.status,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at ?? undefined,\n    projectId: row.project_id ?? undefined,\n    metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\n  }));\n}\n\nexport function updateSessionStatus(\n  db: Database.Database,\n  sessionId: string,\n  status: SessionStatus\n): boolean {\n  const stmt = db.prepare(`\n    UPDATE sessions\n    SET status = ?, updated_at = ?\n    WHERE id = ?\n  `);\n\n  const result = stmt.run(status, new Date().toISOString(), sessionId);\n  return result.changes > 0;\n}\n\nexport function findSessionByUrl(\n  db: Database.Database,\n  url: string\n): Session | null {\n  const stmt = db.prepare(`\n    SELECT id, url, status, created_at, updated_at, project_id, metadata\n    FROM sessions\n    WHERE url = ? AND status = 'active'\n    ORDER BY created_at DESC\n    LIMIT 1\n  `);\n\n  const row = stmt.get(url) as {\n    id: string;\n    url: string;\n    status: SessionStatus;\n    created_at: string;\n    updated_at: string | null;\n    project_id: string | null;\n    metadata: string | null;\n  } | undefined;\n\n  if (!row) return null;\n\n  return {\n    id: row.id,\n    url: row.url,\n    status: row.status,\n    createdAt: row.created_at,\n    updatedAt: row.updated_at ?? undefined,\n    projectId: row.project_id ?? undefined,\n    metadata: row.metadata ? JSON.parse(row.metadata) : undefined,\n  };\n}\n\n// =============================================================================\n// Annotation Operations\n// =============================================================================\n\nexport function upsertAnnotation(\n  db: Database.Database,\n  annotation: Annotation\n): Annotation {\n  const now = new Date().toISOString();\n  const data = JSON.stringify(annotation);\n\n  const stmt = db.prepare(`\n    INSERT INTO annotations (id, session_id, data, created_at, updated_at)\n    VALUES (?, ?, ?, ?, ?)\n    ON CONFLICT(id) DO UPDATE SET\n      data = excluded.data,\n      updated_at = excluded.updated_at\n  `);\n\n  stmt.run(\n    annotation.id,\n    annotation.sessionId,\n    data,\n    annotation.createdAt ?? now,\n    now\n  );\n\n  return annotation;\n}\n\nexport function getAnnotation(\n  db: Database.Database,\n  annotationId: string\n): Annotation | null {\n  const stmt = db.prepare(`\n    SELECT data FROM annotations WHERE id = ?\n  `);\n\n  const row = stmt.get(annotationId) as { data: string } | undefined;\n  if (!row) return null;\n\n  return JSON.parse(row.data);\n}\n\nexport function getAnnotationsForSession(\n  db: Database.Database,\n  sessionId: string\n): Annotation[] {\n  const stmt = db.prepare(`\n    SELECT data FROM annotations\n    WHERE session_id = ?\n    ORDER BY created_at ASC\n  `);\n\n  const rows = stmt.all(sessionId) as Array<{ data: string }>;\n  return rows.map((row) => JSON.parse(row.data));\n}\n\nexport function updateAnnotation(\n  db: Database.Database,\n  annotationId: string,\n  updates: Partial<Annotation>\n): Annotation | null {\n  const existing = getAnnotation(db, annotationId);\n  if (!existing) return null;\n\n  const updated: Annotation = {\n    ...existing,\n    ...updates,\n    updatedAt: new Date().toISOString(),\n  };\n\n  return upsertAnnotation(db, updated);\n}\n\nexport function deleteAnnotation(\n  db: Database.Database,\n  annotationId: string\n): boolean {\n  const stmt = db.prepare('DELETE FROM annotations WHERE id = ?');\n  const result = stmt.run(annotationId);\n  return result.changes > 0;\n}\n\nexport function getPendingAnnotations(\n  db: Database.Database,\n  sessionId: string\n): Annotation[] {\n  const annotations = getAnnotationsForSession(db, sessionId);\n  return annotations.filter((a) => a.status === 'pending' || !a.status);\n}\n\nexport function getAllPendingAnnotations(db: Database.Database): Annotation[] {\n  const stmt = db.prepare(`\n    SELECT data FROM annotations\n    ORDER BY created_at ASC\n  `);\n\n  const rows = stmt.all() as Array<{ data: string }>;\n  const annotations = rows.map((row) => JSON.parse(row.data) as Annotation);\n\n  return annotations.filter((a) => a.status === 'pending' || !a.status);\n}\n","/**\n * HTTP Server for MCP\n * Provides REST API for React Native app communication\n *\n * @see https://github.com/benjitaylor/agentation/blob/main/mcp/src/server/http.ts\n */\n\nimport express, { Express, Request, Response } from 'express';\nimport cors from 'cors';\nimport type Database from 'better-sqlite3';\nimport type {\n  Annotation,\n  Session,\n  ActionRequest,\n  ActionResponse,\n  HealthCheckResponse,\n} from '../types';\nimport {\n  createSession,\n  getSession,\n  getSessionWithAnnotations,\n  listSessions,\n  findSessionByUrl,\n  upsertAnnotation,\n  getAnnotation,\n  updateAnnotation,\n  deleteAnnotation,\n  getPendingAnnotations,\n  getAllPendingAnnotations,\n} from './sqlite';\nimport { generateId } from '../utils';\n\nconst VERSION = '0.1.0';\n\n// =============================================================================\n// Event Emitter for Action Requests\n// =============================================================================\n\ntype ActionListener = (request: ActionRequest) => void;\nconst actionListeners = new Map<string, ActionListener[]>();\n\nexport function onAction(sessionId: string, listener: ActionListener): () => void {\n  const listeners = actionListeners.get(sessionId) ?? [];\n  listeners.push(listener);\n  actionListeners.set(sessionId, listeners);\n\n  return () => {\n    const updated = (actionListeners.get(sessionId) ?? []).filter((l) => l !== listener);\n    if (updated.length === 0) {\n      actionListeners.delete(sessionId);\n    } else {\n      actionListeners.set(sessionId, updated);\n    }\n  };\n}\n\nfunction emitAction(request: ActionRequest): void {\n  const listeners = actionListeners.get(request.sessionId) ?? [];\n  listeners.forEach((listener) => listener(request));\n}\n\n// =============================================================================\n// Webhook Support\n// =============================================================================\n\nasync function sendWebhooks(\n  urls: string[],\n  payload: unknown\n): Promise<void> {\n  for (const url of urls) {\n    try {\n      await fetch(url, {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(payload),\n      });\n    } catch (error) {\n      console.error(`Webhook failed for ${url}:`, error);\n    }\n  }\n}\n\n// =============================================================================\n// HTTP Server\n// =============================================================================\n\nexport function createHttpServer(\n  db: Database.Database,\n  webhookUrls: string[] = []\n): Express {\n  const app = express();\n\n  app.use(cors());\n  app.use(express.json());\n\n  // Health check\n  app.get('/health', (_req: Request, res: Response) => {\n    const response: HealthCheckResponse = { status: 'ok', version: VERSION };\n    res.json(response);\n  });\n\n  // ==========================================================================\n  // Session Endpoints\n  // ==========================================================================\n\n  // List sessions\n  app.get('/sessions', (req: Request, res: Response) => {\n    const status = req.query.status as string | undefined;\n    const limit = parseInt(req.query.limit as string) || 100;\n\n    const sessions = listSessions(\n      db,\n      status as Session['status'] | undefined,\n      limit\n    );\n    res.json(sessions);\n  });\n\n  // Create session\n  app.post('/sessions', (req: Request, res: Response) => {\n    const { url, projectId, metadata } = req.body;\n\n    if (!url) {\n      res.status(400).json({ error: 'url is required' });\n      return;\n    }\n\n    // Check if session already exists for this URL\n    const existing = findSessionByUrl(db, url);\n    if (existing) {\n      res.json(existing);\n      return;\n    }\n\n    const id = generateId();\n    const session = createSession(db, id, url, projectId, metadata);\n    res.status(201).json(session);\n  });\n\n  // Get session\n  app.get('/sessions/:sessionId', (req: Request, res: Response) => {\n    const { sessionId } = req.params;\n    const session = getSessionWithAnnotations(db, sessionId);\n\n    if (!session) {\n      res.status(404).json({ error: 'Session not found' });\n      return;\n    }\n\n    res.json(session);\n  });\n\n  // ==========================================================================\n  // Annotation Endpoints\n  // ==========================================================================\n\n  // Sync annotation (create or update)\n  app.post('/sessions/:sessionId/annotations', (req: Request, res: Response) => {\n    const { sessionId } = req.params;\n    const annotation: Annotation = req.body;\n\n    // Verify session exists\n    const session = getSession(db, sessionId);\n    if (!session) {\n      res.status(404).json({ error: 'Session not found' });\n      return;\n    }\n\n    // Ensure annotation has required fields\n    if (!annotation.id) {\n      annotation.id = generateId();\n    }\n    annotation.sessionId = sessionId;\n    annotation.createdAt = annotation.createdAt ?? new Date().toISOString();\n    annotation.status = annotation.status ?? 'pending';\n\n    const saved = upsertAnnotation(db, annotation);\n\n    // Fire webhook\n    if (webhookUrls.length > 0) {\n      sendWebhooks(webhookUrls, {\n        event: 'annotation.created',\n        timestamp: new Date().toISOString(),\n        data: { sessionId, annotation: saved },\n      });\n    }\n\n    res.status(201).json(saved);\n  });\n\n  // Update annotation\n  app.patch('/annotations/:annotationId', (req: Request, res: Response) => {\n    const { annotationId } = req.params;\n    const updates: Partial<Annotation> = req.body;\n\n    const updated = updateAnnotation(db, annotationId, updates);\n    if (!updated) {\n      res.status(404).json({ error: 'Annotation not found' });\n      return;\n    }\n\n    // Fire webhook\n    if (webhookUrls.length > 0) {\n      sendWebhooks(webhookUrls, {\n        event: 'annotation.updated',\n        timestamp: new Date().toISOString(),\n        data: { annotation: updated },\n      });\n    }\n\n    res.json(updated);\n  });\n\n  // Delete annotation\n  app.delete('/annotations/:annotationId', (req: Request, res: Response) => {\n    const { annotationId } = req.params;\n\n    const annotation = getAnnotation(db, annotationId);\n    const deleted = deleteAnnotation(db, annotationId);\n\n    if (!deleted) {\n      res.status(404).json({ error: 'Annotation not found' });\n      return;\n    }\n\n    // Fire webhook\n    if (webhookUrls.length > 0 && annotation) {\n      sendWebhooks(webhookUrls, {\n        event: 'annotation.deleted',\n        timestamp: new Date().toISOString(),\n        data: { annotation },\n      });\n    }\n\n    res.status(204).send();\n  });\n\n  // Get pending annotations for session\n  app.get('/sessions/:sessionId/pending', (req: Request, res: Response) => {\n    const { sessionId } = req.params;\n\n    const session = getSession(db, sessionId);\n    if (!session) {\n      res.status(404).json({ error: 'Session not found' });\n      return;\n    }\n\n    const pending = getPendingAnnotations(db, sessionId);\n    res.json(pending);\n  });\n\n  // Get all pending annotations\n  app.get('/pending', (_req: Request, res: Response) => {\n    const pending = getAllPendingAnnotations(db);\n    res.json(pending);\n  });\n\n  // ==========================================================================\n  // Action Endpoint (for \"Send to Agent\")\n  // ==========================================================================\n\n  app.post('/sessions/:sessionId/action', (req: Request, res: Response) => {\n    const { sessionId } = req.params;\n    const { annotations, output } = req.body;\n\n    const session = getSession(db, sessionId);\n    if (!session) {\n      res.status(404).json({ error: 'Session not found' });\n      return;\n    }\n\n    const actionRequest: ActionRequest = {\n      sessionId,\n      annotations,\n      output,\n      timestamp: new Date().toISOString(),\n    };\n\n    // Emit to MCP listeners (for wait_for_action)\n    emitAction(actionRequest);\n\n    // Fire webhook\n    if (webhookUrls.length > 0) {\n      sendWebhooks(webhookUrls, {\n        event: 'action.requested',\n        timestamp: new Date().toISOString(),\n        data: actionRequest,\n      });\n    }\n\n    const response: ActionResponse = {\n      success: true,\n      actionId: generateId(),\n    };\n\n    res.json(response);\n  });\n\n  return app;\n}\n\nexport function startHttpServer(\n  app: Express,\n  port: number\n): Promise<void> {\n  return new Promise((resolve) => {\n    app.listen(port, () => {\n      console.log(`Agentation RN MCP HTTP server running on port ${port}`);\n      resolve();\n    });\n  });\n}\n","/**\n * Utility functions for MCP server\n */\n\n/**\n * Generate a unique ID\n */\nexport function generateId(): string {\n  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;\n}\n\n/**\n * Parse webhook URLs from comma-separated string\n */\nexport function parseWebhookUrls(urlString?: string): string[] {\n  if (!urlString) return [];\n  return urlString\n    .split(',')\n    .map((url) => url.trim())\n    .filter((url) => url.length > 0);\n}\n","/**\n * MCP Server Implementation\n * Provides tools for Claude Code to interact with annotations\n *\n * @see https://github.com/benjitaylor/agentation/blob/main/mcp/src/server/mcp.ts\n */\n\nimport { Server } from '@modelcontextprotocol/sdk/server/index.js';\nimport { StdioServerTransport } from '@modelcontextprotocol/sdk/server/stdio.js';\nimport {\n  CallToolRequestSchema,\n  ListToolsRequestSchema,\n} from '@modelcontextprotocol/sdk/types.js';\nimport type Database from 'better-sqlite3';\nimport type {\n  Annotation,\n  ListSessionsInput,\n  GetSessionInput,\n  GetPendingInput,\n  AcknowledgeInput,\n  ResolveInput,\n  DismissInput,\n  ReplyInput,\n  WaitForActionInput,\n  ActionRequest,\n} from '../types';\nimport {\n  listSessions,\n  getSessionWithAnnotations,\n  getPendingAnnotations,\n  getAllPendingAnnotations,\n  updateAnnotation,\n  getAnnotation,\n} from './sqlite';\nimport { onAction } from './http';\nimport { generateId } from '../utils';\n\n// =============================================================================\n// Tool Definitions\n// =============================================================================\n\nconst TOOLS = [\n  {\n    name: 'agentation_list_sessions',\n    description: 'List all feedback sessions. Returns sessions with their status and metadata.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        status: {\n          type: 'string',\n          enum: ['active', 'approved', 'closed'],\n          description: 'Filter by session status',\n        },\n        limit: {\n          type: 'number',\n          description: 'Maximum number of sessions to return (default: 100)',\n        },\n      },\n    },\n  },\n  {\n    name: 'agentation_get_session',\n    description: 'Get a specific session with all its annotations.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        sessionId: {\n          type: 'string',\n          description: 'The session ID to retrieve',\n        },\n      },\n      required: ['sessionId'],\n    },\n  },\n  {\n    name: 'agentation_get_pending',\n    description: 'Get all pending (unresolved) annotations for a specific session.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        sessionId: {\n          type: 'string',\n          description: 'The session ID',\n        },\n      },\n      required: ['sessionId'],\n    },\n  },\n  {\n    name: 'agentation_get_all_pending',\n    description: 'Get all pending annotations across all sessions.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {},\n    },\n  },\n  {\n    name: 'agentation_acknowledge',\n    description: 'Mark an annotation as acknowledged. Use this when you\\'ve seen the feedback and are working on it.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        annotationId: {\n          type: 'string',\n          description: 'The annotation ID to acknowledge',\n        },\n      },\n      required: ['annotationId'],\n    },\n  },\n  {\n    name: 'agentation_resolve',\n    description: 'Mark an annotation as resolved. Use this when you\\'ve addressed the feedback.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        annotationId: {\n          type: 'string',\n          description: 'The annotation ID to resolve',\n        },\n        message: {\n          type: 'string',\n          description: 'Optional resolution message explaining what was done',\n        },\n      },\n      required: ['annotationId'],\n    },\n  },\n  {\n    name: 'agentation_dismiss',\n    description: 'Dismiss an annotation. Use this for feedback that won\\'t be addressed.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        annotationId: {\n          type: 'string',\n          description: 'The annotation ID to dismiss',\n        },\n        reason: {\n          type: 'string',\n          description: 'Reason for dismissing the annotation',\n        },\n      },\n      required: ['annotationId', 'reason'],\n    },\n  },\n  {\n    name: 'agentation_reply',\n    description: 'Add a reply to an annotation thread. Use this to ask clarifying questions or provide updates.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        annotationId: {\n          type: 'string',\n          description: 'The annotation ID to reply to',\n        },\n        message: {\n          type: 'string',\n          description: 'The reply message',\n        },\n      },\n      required: ['annotationId', 'message'],\n    },\n  },\n  {\n    name: 'agentation_wait_for_action',\n    description: 'Wait for the user to click \"Send to Agent\" in the app. Blocks until action is received or timeout.',\n    inputSchema: {\n      type: 'object' as const,\n      properties: {\n        sessionId: {\n          type: 'string',\n          description: 'The session ID to wait on',\n        },\n        timeoutMs: {\n          type: 'number',\n          description: 'Timeout in milliseconds (default: 60000)',\n        },\n      },\n      required: ['sessionId'],\n    },\n  },\n];\n\n// =============================================================================\n// Tool Handlers\n// =============================================================================\n\nfunction handleListSessions(\n  db: Database.Database,\n  input: ListSessionsInput\n): string {\n  const sessions = listSessions(db, input.status, input.limit);\n  return JSON.stringify(sessions, null, 2);\n}\n\nfunction handleGetSession(\n  db: Database.Database,\n  input: GetSessionInput\n): string {\n  const session = getSessionWithAnnotations(db, input.sessionId);\n  if (!session) {\n    return JSON.stringify({ error: 'Session not found' });\n  }\n  return JSON.stringify(session, null, 2);\n}\n\nfunction handleGetPending(\n  db: Database.Database,\n  input: GetPendingInput\n): string {\n  const pending = getPendingAnnotations(db, input.sessionId);\n  return JSON.stringify(pending, null, 2);\n}\n\nfunction handleGetAllPending(db: Database.Database): string {\n  const pending = getAllPendingAnnotations(db);\n  return JSON.stringify(pending, null, 2);\n}\n\nfunction handleAcknowledge(\n  db: Database.Database,\n  input: AcknowledgeInput\n): string {\n  const updated = updateAnnotation(db, input.annotationId, {\n    status: 'acknowledged',\n  });\n\n  if (!updated) {\n    return JSON.stringify({ error: 'Annotation not found' });\n  }\n\n  return JSON.stringify({ success: true, annotation: updated });\n}\n\nfunction handleResolve(\n  db: Database.Database,\n  input: ResolveInput\n): string {\n  const annotation = getAnnotation(db, input.annotationId);\n  if (!annotation) {\n    return JSON.stringify({ error: 'Annotation not found' });\n  }\n\n  const thread = annotation.thread ?? [];\n  if (input.message) {\n    thread.push({\n      id: generateId(),\n      role: 'agent',\n      content: input.message,\n      timestamp: Date.now(),\n    });\n  }\n\n  const updated = updateAnnotation(db, input.annotationId, {\n    status: 'resolved',\n    resolvedAt: new Date().toISOString(),\n    resolvedBy: 'agent',\n    thread,\n  });\n\n  return JSON.stringify({ success: true, annotation: updated });\n}\n\nfunction handleDismiss(\n  db: Database.Database,\n  input: DismissInput\n): string {\n  const annotation = getAnnotation(db, input.annotationId);\n  if (!annotation) {\n    return JSON.stringify({ error: 'Annotation not found' });\n  }\n\n  const thread = annotation.thread ?? [];\n  thread.push({\n    id: generateId(),\n    role: 'agent',\n    content: `Dismissed: ${input.reason}`,\n    timestamp: Date.now(),\n  });\n\n  const updated = updateAnnotation(db, input.annotationId, {\n    status: 'dismissed',\n    thread,\n  });\n\n  return JSON.stringify({ success: true, annotation: updated });\n}\n\nfunction handleReply(\n  db: Database.Database,\n  input: ReplyInput\n): string {\n  const annotation = getAnnotation(db, input.annotationId);\n  if (!annotation) {\n    return JSON.stringify({ error: 'Annotation not found' });\n  }\n\n  const thread = annotation.thread ?? [];\n  thread.push({\n    id: generateId(),\n    role: 'agent',\n    content: input.message,\n    timestamp: Date.now(),\n  });\n\n  const updated = updateAnnotation(db, input.annotationId, { thread });\n\n  return JSON.stringify({ success: true, annotation: updated });\n}\n\nasync function handleWaitForAction(\n  input: WaitForActionInput\n): Promise<string> {\n  const timeout = input.timeoutMs ?? 60000;\n\n  return new Promise((resolve) => {\n    const timer = setTimeout(() => {\n      cleanup();\n      resolve(JSON.stringify({ timeout: true, message: 'No action received within timeout' }));\n    }, timeout);\n\n    const cleanup = onAction(input.sessionId, (request: ActionRequest) => {\n      clearTimeout(timer);\n      resolve(JSON.stringify(request, null, 2));\n    });\n  });\n}\n\n// =============================================================================\n// MCP Server\n// =============================================================================\n\nexport function createMcpServer(db: Database.Database): Server {\n  const server = new Server(\n    {\n      name: 'agentation-rn-mcp',\n      version: '0.1.0',\n    },\n    {\n      capabilities: {\n        tools: {},\n      },\n    }\n  );\n\n  // List available tools\n  server.setRequestHandler(ListToolsRequestSchema, async () => {\n    return { tools: TOOLS };\n  });\n\n  // Handle tool calls\n  server.setRequestHandler(CallToolRequestSchema, async (request) => {\n    const { name, arguments: args } = request.params;\n\n    try {\n      let result: string;\n\n      switch (name) {\n        case 'agentation_list_sessions':\n          result = handleListSessions(db, args as ListSessionsInput);\n          break;\n        case 'agentation_get_session':\n          result = handleGetSession(db, args as GetSessionInput);\n          break;\n        case 'agentation_get_pending':\n          result = handleGetPending(db, args as GetPendingInput);\n          break;\n        case 'agentation_get_all_pending':\n          result = handleGetAllPending(db);\n          break;\n        case 'agentation_acknowledge':\n          result = handleAcknowledge(db, args as AcknowledgeInput);\n          break;\n        case 'agentation_resolve':\n          result = handleResolve(db, args as ResolveInput);\n          break;\n        case 'agentation_dismiss':\n          result = handleDismiss(db, args as DismissInput);\n          break;\n        case 'agentation_reply':\n          result = handleReply(db, args as ReplyInput);\n          break;\n        case 'agentation_wait_for_action':\n          result = await handleWaitForAction(args as WaitForActionInput);\n          break;\n        default:\n          result = JSON.stringify({ error: `Unknown tool: ${name}` });\n      }\n\n      return {\n        content: [{ type: 'text', text: result }],\n      };\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      return {\n        content: [{ type: 'text', text: JSON.stringify({ error: message }) }],\n        isError: true,\n      };\n    }\n  });\n\n  return server;\n}\n\nexport async function startMcpServer(server: Server): Promise<void> {\n  const transport = new StdioServerTransport();\n  await server.connect(transport);\n  console.error('Agentation RN MCP server running on stdio');\n}\n"],"mappings":"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","names":["Database","express","cors","resolve","resolve"]}